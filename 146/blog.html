<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title>Graceful Shutdown - 250bpm</title>
    
    	<script type="text/javascript" src="http://www.wikidot.com/default__flow/login__CustomDomainScript?site_id=148706"></script>

    
    <script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--javascript/init.combined.js"></script>
    <script  type="text/javascript">
        var URL_HOST = 'www.wikidot.com';
        var URL_DOMAIN = 'wikidot.com';
        var USE_SSL =  true ;
        var URL_STATIC = 'http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9';
        // global request information
        
        var WIKIREQUEST = {};
        WIKIREQUEST.info = {};
        
        WIKIREQUEST.info.domain = "250bpm.com";
        WIKIREQUEST.info.siteId = 148706;
        WIKIREQUEST.info.siteUnixName = "250bpm";
        WIKIREQUEST.info.categoryId = 2550760;
        WIKIREQUEST.info.themeId = 18520;
        WIKIREQUEST.info.requestPageName = "blog:146";
        OZONE.request.timestamp = 1594263599;
        OZONE.request.date = new Date();
        WIKIREQUEST.info.lang = 'en';
                WIKIREQUEST.info.pageUnixName = "blog:146";
        WIKIREQUEST.info.pageId = 598886455;
                        WIKIREQUEST.info.lang = "en";
        OZONE.lang = "en";
        var isUAMobile = !!/Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    </script>
    
    


    
        <script  type="text/javascript">
    
        require.config({
            baseUrl: URL_STATIC + '/common--javascript',
            paths: {
                'jquery.ui': 'jquery-ui.min',
                'jquery.form': 'jquery.form'
            }
        });
    
    </script>
    
    <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
            
    
    
    
    
    <meta http-equiv="content-language" content="en"/>
    <script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--javascript/WIKIDOT.combined.js"></script>
        
    
    <style type="text/css" id="internal-style">
        
        /* modules */
        
                
        /* theme */
                    @import url(http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--theme/base/css/style.css);
                    @import url(http://250bpm.wdfiles.com/local--theme/250bpm/style.css);
            </style>
    
        
        
        
    <link rel="shortcut icon" href="/local--favicon/favicon.gif"/>
    <link rel="icon" type="image/gif" href="/local--favicon/favicon.gif"/>
    
            <link rel="apple-touch-icon" href="/common--images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="/common--images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="/common--images/apple-touch-icon-114x114.png" />
        
        
            <link rel="alternate" type="application/wiki" title="Edit this page" href="javascript:WIKIDOT.page.listeners.editClick()"/>
    
        <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-18234656-1']);
        _gaq.push(['_setDomainName', 'none']);
        _gaq.push(['_setAllowLinker', true]);
        _gaq.push(['_trackPageview']);

        _gaq.push(['old._setAccount', 'UA-68540-5']);
        _gaq.push(['old._setDomainName', 'none']);
        _gaq.push(['old._setAllowLinker', true]);
        _gaq.push(['old._trackPageview']);

                _gaq.push(['userTracker._setAccount', 'UA-3207370-9']);
        _gaq.push(['userTracker._trackPageview']);
            </script>
    
    <script type="text/javascript">
        window.google_analytics_uacct = 'UA-18234656-1';
        window.google_analytics_domain_name = 'none';
    </script>
    
        <link rel="manifest" href="/onesignal/manifest.json" />
    <script src="https://cdn.onesignal.com/sdks/OneSignalSDK.js" acync=""></script>
    <script>
        var OneSignal = window.OneSignal || [];
        OneSignal.push(function() {
          OneSignal.init({
            appId: null,
          });
        });
    </script>
        
<link rel="alternate" type="application/rss+xml" title="Comments for the page &quot;Graceful Shutdown&quot;" href="/feed/page/comments-598886455.xml"/><script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--modules/js/forum/ForumCommentsModule.js"></script>
<script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--modules/js/forum/ForumViewThreadModule.js"></script>
<script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--modules/js/forum/ForumViewThreadPostsModule.js"></script>
<script type="text/javascript" src="http://d3g0gp89917ko0.cloudfront.net/v--3e3a6f7dbcc9/common--modules/js/forum/sub/ForumNewPostFormModule.js"></script>
</head>
<body id="html-body">
<div id="skrollr-body">
<a name="page-top"></a>





<div id="container-wrap-wrap">
    <div id="container-wrap">
        <div id="container">
            <div id="header">
              <h1><a href="/"><span>250bpm</span></a></h1>
                
                
                <!-- google_ad_section_start(weight=ignore) -->
                
                <div id="search-top-box" class="form-search">
    <form id="search-top-box-form" action="dummy" class="input-append">
        <input id="search-top-box-input" class="text empty search-query" type="text" size="15" name="query" value="Search this site" onfocus="if(YAHOO.util.Dom.hasClass(this, 'empty')){YAHOO.util.Dom.removeClass(this,'empty'); this.value='';}"/><input class="button btn" type="submit" name="search" value="Search"/>
    </form>
</div>
                
                
                    <div id="top-bar">
                        

<ul>
<li><a href="/">Home</a></li>
<li><a href="https://github.com/sustrik/cartesian">Cartesian</a></li>
<li><a href="http://libdill.org">Libdill</a></li>
<li><a href="http://nanomsg.org">Nanomsg</a></li>
<li><a href="https://github.com/sustrik/tiles">Tiles</a></li>
<li><a href="http://zero.mq">ZeroMQ</a></li>
<li><a href="/contact">Contact</a></li>
</ul>

                    </div>
                
                <div id="login-status"><a href="javascript:;" onclick="WIKIDOT.page.listeners.createAccount(event)" class="login-status-create-account btn">Create account</a> <span>or</span> <a href="javascript:;" onclick="WIKIDOT.page.listeners.loginClick(event)" class="login-status-sign-in btn btn-primary">Sign in</a> </div>
                <div id="header-extra-div-1"><span></span></div><div id="header-extra-div-2"><span></span></div><div id="header-extra-div-3"><span></span></div>
            </div>
            
            <div id="content-wrap">
                
                    <div id="side-bar">
                        


                        


                        


                    </div>
                
                
                <!-- google_ad_section_end -->
                
                <div id="main-content">
                    <div id="action-area-top"></div>
                    
                    
                        <div id="page-title">
                            Graceful Shutdown
                        </div>
                    

                    

                    



                    <div id="page-content">
                        

<div style="width:50em">
<p><strong>WARNING</strong>: The claims about composability of the graceful shudown construct have been defeated in the discussion <a href="https://trio.discourse.group/t/graceful-shutdown/93">here</a>. Or maybe not. Judge for yourself. However, most of the analysis in this article is still relevant.</p>
<h3 id="toc0"><span>Introduction</span></h3>
<p>Within a structured concurrency world, graceful shutdown is a little understood, little addressed and confusing topic.</p>
<p>I've been fighting with it myself for almost a year (longer than with any other problem I can recall) and it haven't been a pleasant experience. If felt like running in circles. Too many contradictory requirements, to much complexity and too often a solution I've came up with turned out to be one of the solution I've already rejected in disguise.</p>
<p>Nathaniel Smith on <a href="https://trio.discourse.group/c/structured-concurrency">structured concurrency forum</a> helpfully pointed me to the <a href="https://github.com/python-trio/trio/issues/147">discussion about graceful shutdowns in Trio</a> and oh boy, does that discussion sound familiar.</p>
<p>Anyway, finally I've came up with a solution that's simple and works for all use cases. But it turns out it's one of those ideas that seem not to make sense until something clicks in one's mind. From there on though, they seem perfectly obvious, up to the point where one wonders how the others can possibly not get it.</p>
<p>In this post I'll try to explain.</p>
<h3 id="toc1"><span>The use case</span></h3>
<p>The classic use case for graceful shutdown is a web server. It's handling many connections from the clients. When it's being shut down, you want it to happen in a controlled manner so that clients don't end up with half-loaded pages and such. Specifically, you want to stop the accept loop to make sure that no new connections are being made. Then you want to wait for say 10 seconds to give existing connections time to finish their work. Finally, when the time is up, you want to cancel any remaining connections and exit the process.</p>
<p>Of course, the nature of the workload may vary. Web server needs to shut down connections. CRUD application needs to shut down its connection to database. Yet different application may want to save data to disk before exiting.</p>
<h3 id="toc2"><span>What's graceful shutdown, anyway?</span></h3>
<p>Graceful shutdown intuitively seems to be some kind of cancellation. Here, I would like to compare it to the classic hard cancellation and argue that graceful shutdown isn't anything like it.</p>
<p>Let's have a look at hard coroutine cancellation first. The code of the coroutine looks like this:</p>
<div class="code">
<pre>
<code>rc = send(s, &quot;Hello!&quot;);
if(rc == ECANCELED) return;
rc = recv(s, &amp;msg);
if(rc == ECANCELED) return;
rc = sleep(60);
if(rc == ECANCELED) return;</code>
</pre></div>
<p>When parent coroutine hard-cancels a child coroutine, a blocking call within the coroutine will immediately return an error (or, in high-level languages, it will throw an exception) and the coroutine will exit.</p>
<p>Think of hard cancellation as &quot;asking the coroutine to return immediately&quot;. In reality, it may do some bookkeeping tasks before exiting (freeing the allocated memory etc.) but form the perspective of this article, thinking of hard cancellation as eliciting immediate &quot;return&quot; in the coroutine is a pretty good approximation.</p>
<p>Now have a look at graceful shutdown.</p>
<p>It's very different. By saying &quot;shut down gracefully&quot; we are asking the coroutine to finish whatever it was doing and start doing different kind of work, namely it's shutdown business logic. So, for example, while during its normal lifetime it may be receiving data from the network and writing them to the database, after graceful shutdown request it may want to exchange terminal handshakes with the network peers and start flushing any in-memory data to the database.</p>
<p>Not only is graceful shutdown not immediate. It can be arbitrarily long or even infinite. Consider the case when you are trying to exchange a terminal handshake with a network peer. If the peer is not responding, the graceful shutdown will never finish.</p>
<h3 id="toc3"><span>More on the nature of graceful shutdown: In-band vs. out of band</span></h3>
<p>Consider a case where the parent coroutine sends the child coroutine a stream of tasks to process. It does so via a channel. It may send DoA, DoB and DoC requests. Then it hard-cancels the child. Hard cancellation is supposed to be immediate and so the child coroutine exits even though DoA, DoB and DoC haven't been processed yet.</p>
<div class="image-container aligncenter"><img src="http://250bpm.wdfiles.com/local--files/blog:146/gs1.png" alt="gs1.png" class="image" /></div>
<p>Does the graceful shutdown work is a similar way? No. Graceful shutdown means &quot;finish whatever you are doing but take your time and be careful; don't break the business logic&quot;. During graceful shutdown you definitely don't want to drop the requests on the floor. So, instead of sending an out-of-band signal, like hard cancel did, you just write an application-defined STOP message to the channel and leave the child coroutine to do it's work. After it processes DoA, DoB and DoC, it will eventually receive the STOP message. At that point it will do the terminal handshakes, it will flush data to disk and so on. Finally, it will exit.</p>
<div class="image-container aligncenter"><img src="http://250bpm.wdfiles.com/local--files/blog:146/gs2.png" alt="gs2.png" class="image" /></div>
<p>The point I am trying to make here is that while hard-cancel signal travels necessarily out-of-band, the graceful shutdown signal must be, equally necessarily, passed in-band.</p>
<p>And when you think about it a little bit more, &quot;out-of-band&quot; means that the communication channel is created and managed, invisibly to the user, by the language runtime (or a structured concurrency library, such as Trio or libdill) while &quot;in-band&quot; means that the communication channel is business-logic-specific and that it is defined and managed by the application itself.</p>
<p>In consequence, language runtime (or the library) has no way of knowing how to send a graceful shutdown to the child coroutine, even if it wanted to. The coroutine is listening on an application-specific channel. It may be channel A or channel B. It may be listening on both. Or maybe it's listening on channel A up to some point in its lifecycle and then starts listening on channel B. Or maybe it even gets the graceful shutdown request over the network (the latter is common during terminal handshake in network protocols). The language runtime just doesn't know.</p>
<p>Ergo, sending a graceful shutdown request cannot possibly be a feature of the language. It must be done manually by the application.</p>
<h3 id="toc4"><span>Even more on the nature of graceful shutdown: Cancellation points</span></h3>
<p>The rules of hard cancellation are strict: Once a coroutine has been hard-canceled the very next blocking call will immediately return ECANCELED. In other words, every single blocking call is a cancellation point.</p>
<p>Graceful shutdown is different. It allows the coroutine to exit only at special points in the workflow where the business logic is in consistent state.</p>
<p>Consider the case of an RPC server. It reads a message from the peer, does some computation, then sends a reply to the peer.</p>
<p>Graceful shutdown can terminate the coroutine only when it is idling and waiting for a new request.</p>
<p>It we allowed graceful shutdown to terminate the coroutine while it is trying to send the reply, it would mean that a request could go unanswered. And that doesn't deserve to be called &quot;graceful shutdown&quot;.</p>
<h3 id="toc5"><span>Let's summarize</span></h3>
<p>What we learned so far is that hard cancellation:</p>
<ol>
<li>Is triggered via an invisible communication channel created by the language runtime.</li>
<li>It manifests itself inside the target coroutine as an error code (ECANCELED in libdill) or an exception (Cancelled in Trio).</li>
<li>The error (or the exception) can be returned from any blocking call.</li>
<li>In response to it, the coroutine is not expected to do any application-specific work. It should just exit.</li>
</ol>
<p>Graceful shutdown, on the other hand:</p>
<ol>
<li>Is triggered via an application-specific channel.</li>
<li>Manifests itself inside the target coroutine as a plain old message.</li>
<li>The message may only be received at specific, application-defined points in the coroutine.</li>
<li>In response to it, the coroutine can do arbitrary amount of application-specific work.</li>
</ol>
<p>Well, that seems to be it.</p>
<p>Hard cancellation is fully managed by the language. Graceful shutdown is fully managed by the application. From the language designer's perspective there's nothing to see here. We should just move on and forget about the entire business.</p>
<p>Or should we?</p>
<h3 id="toc6"><span>Keeping graceful shutdown in check</span></h3>
<p>Well, it turns out that the parent coroutine often doesn't want graceful shutdown to take forever. It's willing to give it ten seconds to finish, but if that doesn't happen, so be it, c'est la vie, it will just hard-cancel it.</p>
<div class="code">
<pre>
<code>void main() {
    ch = channel();
    b = bundle(); // a.k.a. scope or nursery
    bundle_go(b, worker(ch));
    ...
    send(ch, STOP); // ask the child to shut down gracefully
    sleep(10);
    bundle_cancel(b); // hard-cancel the child if it haven't finished yet 
}</code>
</pre></div>
<p>You may see the problem with this code. It works OK, but it always waits for 10 seconds, even when the child exits immediately. And that sounds like a waste.</p>
<p>So, after all, the language can do something to help with the graceful termination. It can provide a primitive to avoid the ugly non-negotiable sleep() step.</p>
<h3 id="toc7"><span>The proposal</span></h3>
<p>First, let me be clear. I don't propose to add any new concept to the existing structured concurrency model. Not even the concept of &quot;graceful shutdown&quot;. We'll do with the existing concepts of coroutine, bundle (scope, nursery) and plain old hard cancellation.</p>
<p>Second, I propose to add a timeout parameter to the traditional bundle_cancel() method:</p>
<div class="code">
<pre>
<code>bundle_cancel(b, 10);</code>
</pre></div>
<p>The semantics are as follows: The function will wait for 10 seconds for all coroutines in the bundle to finish. If they all do before the timeout expires, the function will exit immediately as the last coroutine finishes. If they don't, it will hard-cancel all the remaining coroutines when the time is up.</p>
<p>In either case, when the function exits there are no more coroutines running in the bundle. If fact, the bundle itself doesn't exist any more.</p>
<p>The function also happens to be a blocking function and thus it behaves as any other blocking function. When the parent coroutine itself is hard-canceled bundle_cancel() hard-cancels all the coroutines in the bundle and returns ECANCELED error to the caller.</p>
<p>NOTE: With timeout set to zero, this is equivalent to the plain old hard cancellation. This has some pretty obvious implications for backward compatibility.</p>
<h3 id="toc8"><span>The examples</span></h3>
<p>I am aware that such a trivial construct doesn't look like it's up to the task of dealing with the hydra of graceful shutdown.</p>
<p>So, to convince you, let us look how it fares in the wild.</p>
<h5 id="toc9"><span>The trivial case</span></h5>
<p>In this scenario the child coroutine does some work and exits.</p>
<div class="code">
<pre>
<code>coroutine void worker(socket_t s) {
    int rc = send(s, &quot;Hello, world!&quot;);
    if(rc == ECANCELED) return;
    message_t msg;
    rc = recv(s, &amp;msg);
    if(rc == ECANCELED) return;
    return;
}

int main(void) {
    socket_t s = create_connected_socket();
    bundle_t b = bundle();
    bundle_go(b, worker(s));
    sleep(60);
    bundle_cancel(b, 10);
    return 0;
}</code>
</pre></div>
<p>Note how the worker coroutine knows nothing about graceful shutdown. It looks exactly the same way as it would if there was only hard cancellation. Yet the parent coroutine still manages to shut it down gracefully!</p>
<p>If the worker manages to finish its work in 10 seconds, the program will exit immediately. If it doesn't manage to finish in time, say if it is stuck in the recv() call, it will get hard-canceled after 10 seconds and the program will exit.</p>
<h5 id="toc10"><span>Infinite loop</span></h5>
<p>This example deals with the question of what happens if the child coroutine never finishes.</p>
<div class="code">
<pre>
<code>coroutine void worker(socket_t s) {
    while(1) {
        int rc = send(s, &quot;Hello, world!&quot;);
        if(rc == ECANCELED) return;
        message_t msg;
        rc = recv(s, &amp;msg);
        if(rc == ECANCELED) return;
    }
}

int main(void) {
    socket_t s = create_connected_socket();
    bundle_t b = bundle();
    bundle_go(b, worker(s));
    sleep(60);
    bundle_cancel(b, 10);
    return 0;
}</code>
</pre></div>
<p>The code is identical to the previous example, except for the forever loop that was added to the worker. And once again, the child doesn't do anything specific to enable graceful shutdown.</p>
<p>You may feel like this example is a bit pointless. The worker coroutine runs at full speed throughout the entire grace period and then it gets hard-cancelled. It's hardly the graceful shutdown of your dreams.</p>
<p>But while that may be true, I am trying to make a point here. And the point is: The parent doesn't have to care.</p>
<p>The parent doesn't have to care whether the coroutine supports a graceful shutdown or not. It doesn't have to worry about how long the shutdown would take. It doesn't have to care whether there are infinite loops or not. It doesn't care if the worker behaves in a pointless way as shown in the example above.</p>
<p>The programmer doesn't have to go and inspect all the coroutines he is using to find out how the graceful shutdown would behave.</p>
<p>He just calls bundle_close(b, 10) and he is guaranteed that the coroutine will be dead in at most 10 seconds.</p>
<h5 id="toc11"><span>Graceful shutdown-aware coroutine</span></h5>
<p>As already mentioned, the language has no concept of graceful shutdown.</p>
<p>Therefore, the parent coroutine has to send the graceful shutdown signal to the worker coroutine manually. It does so via a channel.</p>
<div class="code">
<pre>
<code>coroutine void worker(socket_t s, channel_t ch) {
    while(1) {
        message_t msg;
        int rc = recv_from_socket_or_channel(s, ch, &amp;msg);
        if(rc == ECANCELED) return;
        if(rc == FROM_CHANNEL) goto graceful_shutdown;
        if(rc == FROM_SOCKET) {
            // process msg here
        }
        rc = send(s, &quot;Hello, world!&quot;);
        if(rc == ECANCELED) return;
    }
graceful_shutdown:
    ... // do the entire graceful shutdown thing here
}

int main(void) {
    socket_t s = create_connected_socket();
    channel_t ch = channel();
    bundle_t b = bundle();
    bundle_go(b, worker(s, ch));
    sleep(60);
    send(ch, &quot;STOP&quot;); // ask for graceful shutdown
    bundle_cancel(b, 10); // give it at most 10 seconds to finish
    return 0;
}</code>
</pre></div>
<p>You may have noticed that I've been cheating here. recv_from_socket_or_channel() function hides a lot of complexity and to be fair, I am not aware of a language that has good API for this kind of thing. However, it is unrelated to the topic of graceful shutdown, so I'll let it be for now.</p>
<p>That being said, what I wanted to show here is how the cancellation points for graceful shutdown checkpoints are application-defined. In particular there's only one place in the workflow where STOP message can be received.</p>
<p>The application is basically an RPC server, waiting for a message from a client and then sending a &quot;Hello, world!&quot; reply. And we certainly don't want the client to miss their hello world message! Therefore, the only valid point to deal with the graceful shutdown is when the coroutine is idling, waiting for a new request.</p>
<p>If we checked for STOP before the send call, the coroutine would exit and RPC would end up unanswered. It would a large stretch to call that &quot;graceful shutdown&quot;.</p>
<h5 id="toc12"><span>Graceful shutdown triggered by a network peer</span></h5>
<p>I've already mentioned that it's entirely up to the application to decide how the graceful shutdown signal is delivered to the coroutine. One specific case of this is when the signal comes from the outside.</p>
<p>It's a common scenario with network protocols. Each peer can ask for the connection to be shut down. For example, with WebSockets, each party can send a special <a href="https://tools.ietf.org/html/rfc6455#section-1.4">CLOSE message</a> to inform the peer they want to shut down. The peer should respond by sending CLOSE message of its own.</p>
<p>The following code is a server that responds to CLOSE message from the client.</p>
<div class="code">
<pre>
<code>coroutine void worker(socket_t s) {
    while(1) {
        message_t msg;
        int rc = recv(s, &amp;msg);
        if(rc == ECANCELED) return;
        if(msg == &quot;CLOSE&quot;) break;
        rc = send(s, &quot;Hello, world!&quot;);
        if(rc == ECANCELED) return;
    }
    int rc = send(s, &quot;CLOSE&quot;);
    if(rc == ECANCELED) return;
    return;
}

int main(void) {
    socket_t s = create_connected_socket();
    bundle_t b = bundle();
    bundle_go(b, worker(s));
    sleep(60);
    bundle_cancel(b, 10);
    return 0;
}</code>
</pre></div>
<p>Note how this interacts with the server-initiated graceful shutdown. The worker coroutine replies to CLOSE messages in a straightforward way. On the other hand, when the server is being shut down it stops accepting new connection (left as an exercise for the reader) and gives existing connections 10 seconds to exit. If they don't they'll get hard-canceled.</p>
<p>There's a missing piece of course. When server initiates the graceful shutdown, the worker should send unsolicited CLOSE message to the client to inform it that it wants to shut down the connection and then it should wait for CLOSE in reply.</p>
<p>So here's the full implementation:</p>
<div class="code">
<pre>
<code>coroutine void worker(socket_t s, channel_t ch) {
    while(1) {
        message_t msg;
        int rc = recv_from_socket_or_channel(s, ch, &amp;msg);
        if(rc == ECANCELED) return;
        if(rc == FROM_CHANNEL) goto server_initiated_shutdown;
        if(rc == FROM_SOCKET) {
            if(msg == &quot;CLOSE&quot;) goto peer_initiated_shutdown;
        }
        rc = send(s, &quot;Hello, world!&quot;);
        if(rc == ECANCELED) return;
    }
server_initiated_shutdown:
    int rc = send(s, &quot;CLOSE&quot;);
    if(rc == ECANCELED) return;
    // drop all incoming messages until CLOSE is encountered
    while(1) {
         message_t msg;
         rc = recv(s, &amp;msg);
         if(rc == ECANCELED) return;
         if(msg == &quot;CLOSE&quot;) break;
    }
    return;
peer_initiated_shutdown:
    int rc = send(s, &quot;CLOSE&quot;);
    if(rc == ECANCELED) return;
    return;
}

int main(void) {
    socket_t s = create_connected_socket();
    channel_t ch = channel();
    bundle_t b = bundle();
    bundle_go(b, worker(s, ch));
    sleep(60);
    send(ch, &quot;STOP&quot;); // ask for graceful shutdown
    bundle_cancel(b, 10); // give it at most 10 seconds to finish
    return 0;
}</code>
</pre></div>
<h3 id="toc13"><span>Graceful shutdown is composable</span></h3>
<p>Now that we are done with examples, let's look at the thing from a conceptual point of view.</p>
<p>I've already mentioned that parent coroutine doesn't care about specifics of the shutdown mechanism of the child coroutine. It doesn't care if the child has infinite loops, it doesn't care whether it has application-level support for graceful shutdown and so on.</p>
<p>But there's one more thing it doesn't care about. Guess what. It doesn't care if the child has children of its own.</p>
<p>It also doesn't care whether it is already in the process of graceful shutdown, initiated, for example, by a remote peer, by an internal failure or maybe by some kind of coroutine-wide timeout.</p>
<p>This enforces strict isolation between coroutines and makes the graceful shutdown composable.</p>
<p>Let's illustrate the point on a concrete example:</p>
<div class="code">
<pre>
<code>coroutine void nested_worker(message_t msg) {
    // process the message here
}

coroutine void worker(socket_t s, channel_t ch) {
    bundle_t b = bundle();
    while(1) {
        message_t msg;
        int rc = recv_from_socket_or_channel(s, ch, &amp;msg);
        if(rc == ECANCELED) goto hard_cancellation;
        if(rc == FROM_CHANNEL) goto graceful_shutdown;
        if(rc == FROM_SOCKET) {
            bundle_go(b, nested_worker(msg));
        }
        rc = send(s, &quot;Hello, world!&quot;);
        if(rc == ECANCELED) goto hard_cancellation;
    }
graceful_shutdown:
    rc = bundle_cancel(b, 20); // cancel the nested workers with 20 second grace period
    if(rc == ECANCELED) return;
    return;
hard_cancellation:
    rc = bundle_cancel(b, 0); // cancel the nested worker immediately
    if(rc == ECANCELED) return;
    return;
}

int main(void) {
    socket_t s = create_connected_socket();
    channel_t ch = channel();
    bundle_t b = bundle();
    bundle_go(b, worker(s, ch));
    sleep(60);
    send(ch, &quot;STOP&quot;); // ask for graceful shutdown
    bundle_cancel(b, 10); // give it at most 10 seconds to finish
    return 0;
}</code>
</pre></div>
<p>Note that when the server is being shut down it allows only for 10 second grace period. However, worker(), when being gracefully shut down gives its children 20 second grace period. That sounds like it's going to be a headache, but it turns out it is not.</p>
<p>When the 10 second grace period granted by the main() function expires it hard-cancels the worker(). The worker may be still waiting for its children to finish. But we don't care. Hard-cancelling the worker() means that &quot;bundle_cancel(b, 20)&quot; will immediately hard-cancel all the nested workers and exit with ECANCELED error (double-check the semantics of bundle_cancel() as proposed above).</p>
<p>All in all, we get the intuitive behaviour: The server shuts down in 10 seconds and hard-cancels all the children and grand-children that were still running at the time.</p>
<h3 id="toc14"><span>Implications for higher level languages</span></h3>
<p>It's obvious that in higher level languages a lot of the boilerplate code can be avoided. For example, with &quot;Canceled&quot; exception all the &quot;if(rc == ECANCELED) return;&quot; lines just go away.</p>
<p>However, how to wrap the entire thing into a higher-level level constructs, such as automatic scopes, is a probem yet to be solved.</p>
<p><strong>Feb 16th, 2019</strong></p>
<div class="comments-box">
		
	<div class="options" id="comments-options-hidden" style="display: none">
		<a href="javascript:;" onclick="WIKIDOT.modules.ForumCommentsModule.listeners.showComments(event)">Show Comments</a> 
	</div>
		
	<div id="thread-container" class="thread-container" style="margin-top: 1em">
					


<script type="text/javascript">
	WIKIDOT.forumThreadId = 10322008;
</script>


	<div class="options" id="comments-options-shown">
		<a href="javascript:;" onclick="WIKIDOT.modules.ForumCommentsModule.listeners.hideComments(event)" class="btn btn-default btn-small btn-sm">Hide All Comments</a> 
		<a href="javascript:;" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.unfoldAll(event)" class="btn btn-default btn-small btn-sm">Unfold All</a> 
		<a href="javascript:;" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.foldAll(event)" class="btn btn-default btn-small btn-sm">Fold All</a>
	</div>

<div id="thread-container-posts" style="display: none">
    



	
					
      
    <div class="post-container" id="fpc-4155542">
                      
		<div class="post" id="post-4155542">
		<div class="long">
			<div class="head">
									<div class="options">
						<a href="javascript:;" onclick="togglePostFold(event,4155542)" class="btn btn-default btn-small btn-sm">Fold</a>
					</div>
								<div class="title" id="post-title-4155542">
																		
															</div>
				<div class="info">
					<span class="printuser avatarhover"><a href="javascript:;"><img class="small" src="http://www.gravatar.com/avatar.php?gravatar_id=97c543aca1ac7bbcfb5279d0300c8330&amp;default=http://www.wikidot.com/common--images/avatars/default/a16.png&amp;size=16" alt=""/></a>Nathaniel J. Smith (guest)</span> <span class="odate time_1550323232 format_%25e%20%25b%20%25Y%2C%20%25H%3A%25M%7Cagohover">16 Feb 2019 13:20</span>
														</div>
			</div>
			<div class="content" id="post-content-4155542">
									

<p>I posted a reply on the forum: <a href="https://trio.discourse.group/t/graceful-shutdown/93/5">https://trio.discourse.group/t/graceful-shutdown/93/5</a></p>

							</div>

								
					
						<div class="options">
				
													<strong><a href="javascript:;" onclick="postReply(event,4155542)" class="btn btn-primary btn-small btn-sm">Reply</a></strong> 
																	<a href="javascript:;" onclick="togglePostOptions(event,4155542)" class="btn btn-default btn-small btn-sm">Options</a>
							</div>
									
			<div id="post-options-4155542" class="options" style="display: none">
			</div>
		</div>
		<div class="short">
							<a class="options btn btn-default btn-mini btn-xs" href="javascript:;" onclick="togglePostFold(event,4155542)" c>Unfold</a>
						<a class="title" href="javascript:;" onclick="togglePostFold(event,4155542)"></a> by <span class="printuser avatarhover"><a href="javascript:;"><img class="small" src="http://www.gravatar.com/avatar.php?gravatar_id=97c543aca1ac7bbcfb5279d0300c8330&amp;default=http://www.wikidot.com/common--images/avatars/default/a16.png&amp;size=16" alt=""/></a>Nathaniel J. Smith (guest)</span>, <span class="odate time_1550323232 format_%25e%20%25b%20%25Y%2C%20%25H%3A%25M%7Cagohover">16 Feb 2019 13:20</span>
		</div>
	</div>
 
                
        
            </div>
 



</div>

        <a href="javascript:;" id="new-post-button" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.newPost(event,null)"
      style="display:  none ; margin-bottom:1em"
    >Add a New Comment</a>


    <div id="new-post-form-container">
        <div id="new-post-preview-div" style="display: none">
            <h1>Post preview:</h1>
            <div class="post-container"></div>
            <div></div>
            <a href="javascript:;" onclick="WIKIDOT.modules.ForumNewPostFormModule.listeners.closePreview(event)" class="btn btn-danger">Close preview</a>
        </div>

        <div id="new-post-div" class="well">
            <form id="new-post-form" onkeypress="return OZONE.utils.disableEnterKey(event)">
                <input type="hidden" name="threadId" value="10322008"/>
                <input type="hidden" name="parentId" value=""/>
                                    <table class="guest-commenting">
                        <tr>
                            <td><input class="text form-control" name="guestName" type="text" maxlength="30" value="" title="Name"/></td>
                            <td>or <a href="#action:login">Sign in as Wikidot user</a></td>
                        </tr>
                        <tr>
                            <td><input class="text form-control" name="guestEmail" type="text" maxlength="50" value="" title="E-mail address"/></td>
                            <td>(will not be published)</td>
                        </tr>
                    </table>
                                <div><textarea id="np-text" name="source" rows="10" cols="50" class="form-control"></textarea></div>
                <div class="change-textarea-size">
                    <a href="javascript:;" onclick="WIKIDOT.utils.changeTextareaRowNo('np-text',-5)">-</a>
                    <a href="javascript:;" onclick="WIKIDOT.utils.changeTextareaRowNo('np-text',5)">+</a>
                </div>
                <div class="edit-help-34">
                    Help: <a href="http://www.wikidot.com/doc:quick-reference" target="_blank">wiki text quick reference</a>                </div>
                                
                <div id="edit-post-captcha"></div>
                
                <div class="buttons alignleft">
                    <input class="btn btn-danger btn-small btn-sm" type="button" value="Cancel" id="np-cancel" onclick="WIKIDOT.modules.ForumNewPostFormModule.listeners.cancel(event)"/>
                    <input class="btn btn-default btn-small btn-sm" type="button" value="Preview" id="np-preview" onclick="WIKIDOT.modules.ForumNewPostFormModule.listeners.preview(event)"/>
                    <input class="btn btn-primary btn-small btn-sm" type="button" value="Post it" id="np-post" onclick="WIKIDOT.modules.ForumNewPostFormModule.listeners.save(event)"/>
                </div>
                    
            </form>
        </div>	

    </div> 
            <script type="text/javascript">
            
            $j(function() {
                WIKIDOT.Editor.init("np-text", "np-editor-panel");
            });
            
        </script>
    
 

<div style="display:none" id="post-options-template">
	<a href="javascript:;" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.showPermalink(event,'%POST_ID%')" class="btn btn-default btn-small btn-sm">Permanent Link</a>
			<a href="javascript:;" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.editPost(event,'%POST_ID%')" class="btn btn-default btn-small btn-sm">Edit</a>
			<a href="javascript:;" onclick="WIKIDOT.modules.ForumViewThreadModule.listeners.deletePost(event,'%POST_ID%')" class="btn btn-danger btn-small btn-sm">Delete</a>
</div>
	
			</div>
	
	
	
</div></div>

                    </div>

                    


                    



                    

                    <div id="page-info-break"></div>
                    
                        <div id="page-options-container">
                            
                        </div>
                    
                    <div id="action-area" style="display: none;"></div>
                </div>
            </div>
            
            
            
            <div id="footer" style="display: block; visibility: visible;">
                <div class="options" style="display: block; visibility: visible;">
    <a href="http://www.wikidot.com/doc" id="wikidot-help-button">Help</a>
    &nbsp;|
    <a href="http://www.wikidot.com/legal:terms-of-service" id="wikidot-tos-button">Terms of Service</a>
    &nbsp;|
    <a href="http://www.wikidot.com/legal:privacy-policy" id="wikidot-privacy-button">Privacy</a>
    &nbsp;|
    <a href="javascript:;" id="bug-report-button" onclick="WIKIDOT.page.listeners.pageBugReport(event)">Report a bug</a>
    &nbsp;|
    <a href="javascript:;" id="abuse-report-button" onclick="WIKIDOT.page.listeners.flagPageObjectionable(event)">Flag as objectionable</a>
</div>
Powered by <a href="http://www.wikidot.com">Wikidot.com</a> 
            </div>
            
                <div id="license-area" class="license-area">
                    Unless otherwise stated, the content of this page is licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 License</a>
                </div>
            
            
            



            <div id="extrac-div-1"><span></span></div><div id="extrac-div-2"><span></span></div><div id="extrac-div-3"><span></span></div>
            
            
            
            
                
            
        </div>
        
    </div>
<!-- These extra divs/spans may be used as catch-alls to add extra imagery. -->
<div id="extra-div-1"><span></span></div><div id="extra-div-2"><span></span></div><div id="extra-div-3"><span></span></div>
<div id="extra-div-4"><span></span></div><div id="extra-div-5"><span></span></div><div id="extra-div-6"><span></span></div>
</div>




</div>
<div id="dummy-ondomready-block" style="display: none;" ></div>
    <!-- Google Analytics load -->
    <script type="text/javascript">
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    <!-- Quantcast -->
    <script type="text/javascript">
    _qoptions={
        qacct:"p-edL3gsnUjJzw-"
    };
    (function() {
        var qc = document.createElement('script'); qc.type = 'text/javascript'; qc.async = true;
        qc.src = ('https:' == document.location.protocol ? 'https://secure' : 'http://edge') + '.quantserve.com/quant.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(qc, s);
    })();
    </script>
    <noscript>
        <img src="http://pixel.quantserve.com/pixel/p-edL3gsnUjJzw-.gif" style="display: none;" border="0" height="1" width="1" alt="Quantcast"/>
    </noscript>




<div id="page-options-bottom-tips" style="display: none;">
    <div id="edit-button-hovertip">
        Click here to edit contents of this page.    </div>
</div>
<div id="page-options-bottom-2-tips"  style="display: none;">
    <div id="edit-sections-button-hovertip">
        Click here to toggle editing of individual sections of the page (if possible).         Watch headings for an &quot;edit&quot; link when available.    </div>
    <div id="edit-append-button-hovertip">
        Append content without editing the whole page source.    </div>
    <div id="history-button-hovertip">
        Check out how this page has evolved in the past.    </div>
    <div id="discuss-button-hovertip">
        If you want to discuss contents of this page - this is the easiest way to do it.    </div>
    <div id="files-button-hovertip">
        View and manage file attachments for this page.    </div>
    <div id="site-tools-button-hovertip">
        A few useful tools to manage this Site.    </div>
    <div id="backlinks-button-hovertip">
        See pages that link to and include this page.    </div>
    <div id="rename-move-button-hovertip">
        Change the name (also URL address, possibly the category) of the page.    </div>
    <div id="view-source-button-hovertip">
        View wiki source for this page without editing.    </div>
    <div id="parent-page-button-hovertip">  
        View/set parent page (used for creating breadcrumbs and structured layout).    </div>
            <div id="abuse-report-button-hovertip">
            Notify administrators if there is objectionable content in this page.        </div>
        <div id="bug-report-button-hovertip">
            Something does not work as expected? Find out what you can do.        </div>
        <div id="wikidot-help-button-hovertip">
            General Wikidot.com documentation and help section.        </div>
        <div id="wikidot-tos-button-hovertip">
            Wikidot.com Terms of Service - what you can, what you should not etc.        </div>
        <div id="wikidot-privacy-button-hovertip">
            Wikidot.com Privacy Policy.          
        </div>
    </div>
</body>
</html>