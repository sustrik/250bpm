<!DOCTYPE html>
<!--Converted via md-to-html-->
<html>
 <head>
 </head>
 <body>
  <h1>
   Coroutines in C with Arbitrary Arguments
  </h1>
  <p>
   There are many C coroutine implementations out there.
  </p>
  <p>
   However, they usually allow only a single predefined type of function to be exected as a coroutine. For example, both
   <em>
    libtask
   </em>
   and
   <em>
    libcoro
   </em>
   require that the coroutine has the following prototype:
  </p>
  <pre><code>void foo(void *arg);
</code></pre>
  <p>
   The following toy implementation of coroutines shows how to execute an arbitrary function as a coroutine. The idea is that if the coroutine invocation performs the context switch to the new coroutine straight away, it can use C compiler to put the arguments on the stack and the library doesn't have to handle it itself. Of course, given that coroutines are executed concurrently, any non-void return value is lost.
  </p>
  <pre><code>#define STACK_SIZE 16384
</code></pre>
  <pre><code>volatile int unoptimisable_ = 1;
</code></pre>
  <pre><code>struct cr_ {
</code></pre>
  <pre><code>    struct cr_ *next;
</code></pre>
  <pre><code>    jmp_buf ctx;
</code></pre>
  <pre><code>};
</code></pre>
  <pre><code>struct cr_ main_cr_ = {NULL};
</code></pre>
  <pre><code>struct cr_ *first_cr_ = &amp;main_cr_;
</code></pre>
  <pre><code>struct cr_ *last_cr_ = &amp;main_cr_;
</code></pre>
  <pre><code>#define go(fn) \
</code></pre>
  <pre><code>    do {\
</code></pre>
  <pre><code>        if(!setjmp(first_cr_-&gt;ctx)) {\
</code></pre>
  <pre><code>            char *stack = malloc(STACK_SIZE);\
</code></pre>
  <pre><code>            int anchor_[unoptimisable_];\
</code></pre>
  <pre><code>            char filler_[(char*)&amp;anchor_ - (char*)(stack + STACK_SIZE)];\
</code></pre>
  <pre><code>            struct cr_ cr[unoptimisable_];\
</code></pre>
  <pre><code>            cr-&gt;next = first_cr_;\
</code></pre>
  <pre><code>            first_cr_ = cr;\
</code></pre>
  <pre><code>            char *stack_[unoptimisable_];\
</code></pre>
  <pre><code>            stack_[0] = stack;\
</code></pre>
  <pre><code>            fn;\
</code></pre>
  <pre><code>            free(stack_[0]);\
</code></pre>
  <pre><code>            first_cr_ = first_cr_-&gt;next;\
</code></pre>
  <pre><code>            longjmp(first_cr_-&gt;ctx, 1);\
</code></pre>
  <pre><code>        }\
</code></pre>
  <pre><code>    } while(0)
</code></pre>
  <pre><code>void yield(void) {
</code></pre>
  <pre><code>    if(first_cr_ == last_cr_)
</code></pre>
  <pre><code>        return;
</code></pre>
  <pre><code>    if(setjmp(first_cr_-&gt;ctx))
</code></pre>
  <pre><code>        return;
</code></pre>
  <pre><code>    struct cr_ *cr = first_cr_;
</code></pre>
  <pre><code>    first_cr_ = cr-&gt;next;
</code></pre>
  <pre><code>    cr-&gt;next = NULL;
</code></pre>
  <pre><code>    last_cr_-&gt;next = cr;
</code></pre>
  <pre><code>    last_cr_ = cr;
</code></pre>
  <pre><code>    longjmp(first_cr_-&gt;ctx, 1);
</code></pre>
  <pre><code>}
</code></pre>
  <p>
   And here's a piece of code that uses it. Note how printf — a system function with variable argument list — is invoked like a coroutine:
  </p>
  <pre><code>void foo(int count, const char *text) {
</code></pre>
  <pre><code>    int i;
</code></pre>
  <pre><code>    for(i = 0; i != count; ++i) {
</code></pre>
  <pre><code>        printf("%s\n", text);
</code></pre>
  <pre><code>        yield();
</code></pre>
  <pre><code>    }
</code></pre>
  <pre><code>}
</code></pre>
  <pre><code>int main() {
</code></pre>
  <pre><code>    go(foo(3, "a"));
</code></pre>
  <pre><code>    go(printf("Hello, %s!\n", "world"));
</code></pre>
  <pre><code>    go(foo(2, "b"));
</code></pre>
  <pre><code>    foo(5, "c");
</code></pre>
  <pre><code>    return 0;
</code></pre>
  <pre><code>}
</code></pre>
  <p>
   <strong>
    April 19th, 2015
   </strong>
  </p>
 </body>
</html>